[{"title":"web3基础了解","url":"/blog/2024/03/22/web3/base/","content":"\n\n去中心化，无限分割，\n记账簿。。这玩意是我最大的困惑，尼玛当交易达到了亿级，这个鬼记账簿得多大。。同步这个玩意太耗费时间了吧。\n轻什么玩意，只取一部分\n\n\n-[Java-tron](https://tronprotocol.github.io/documentation-zh/)\n-[wtf](https://www.wtf.academy/)"},{"title":"Spring-Security6.0","url":"/blog/2024/03/21/Spring/spring-security/","content":"\nSpring Security 6引入了很多破坏性的更新，包括废弃代码的删除，方法重命名，全新的配置DSL等，但是架构和基本原理还是保持不变的。\n\n本质上，Spring Security的实现原理很简单，就是提供了一个用于安全验证的Filter。\n\n```\npublic class SimpleSecurityFilter extends HttpFilter {\n    @Override\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {\n        UsernamePasswordToken token = extractUsernameAndPasswordFrom(request);  // (1)\n        if (notAuthenticated(token)) {  // (2)\n            // 用户名密码错误\n            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); // HTTP 401.\n            return;\n        }\n        if (notAuthorized(token, request)) { // (3)\n            // 当前登录用户的权限不足\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN); // HTTP 403\n            return;\n        }\n        // 通过了身份验证和权限校验，继续执行其它Filter，最终到达Servlet\n        chain.doFilter(request, response); // (4)\n    }\n}\n```\n\n在安全领域，由于攻防手段的多样性和认证鉴权方式的复杂性，将所有功能都放在一个Filter中会导致该Filter迅速演变为一个庞大而复杂的类。\n因此，在实际应用场景中，我们常常将这个庞大的Filter拆分成多个小Filter，并将它们链接在一起。每个Filter都只负责特定领域的功能，比如CsrfFilter，AuthenticationFilter，AuthorizationFilter等\n这种概念被称为FilterChain，实际上JarkataEE规范也有相识的概念。通过使用FilterChain，你就可以以插拔的方式添加或移除特定功能的Filter，而无需改动现有的代码。\n\n\n[一文带你读懂Spring Security 6.0的实现原理](https://spring4all.com/forum-post/4256.html)"},{"title":"kotlin基本语法","url":"/blog/2024/03/20/kotlin/base/","content":"\n入口\nfun main() {\n    println(\"Hello world!\")\n}\n\n函数\n\n//sampleStart\nfun sum(a: Int, b: Int): Int {\n    return a + b\n}\n//sampleEnd\n\nfun main() {\n    print(\"sum of 3 and 5 is \")\n    println(sum(3, 5))\n}\n\n变量\n定义只读局部变量使用关键字 val 定义。只能为其赋值一次。\n可重新赋值的变量使用 var 关键字。\n\nwhen写法"},{"title":"web技巧","url":"/blog/2024/03/12/essay/web_skill/","content":"\n# 拦截\n\n[拦截技巧](https://hughfenghen.github.io/posts/2023/12/23/web-spy/#%E6%8B%A6%E6%88%AA%E7%9A%84%E6%96%B9%E6%B3%95)\naxios处理\nxhook\n\n\n"},{"title":"Git相关知识","url":"/blog/2024/03/07/essay/Git/","content":"\ngit rebase\n\n情况\n![](https://img-blog.csdnimg.cn/36efc2704d174acab598c4b9addd3694.png?)\n\n此时我们切换到feature分支上，执行rebase命令，相当于是想要把master分支合并到feature分支（这一步的场景就可以类比为我们在自己的分支feature上开发了一段时间了，准备从主干master上拉一下最新改动。模拟了git pull --rebase的情形）\n\n# 这两条命令等价于git rebase master feature\ngit checkout feature\ngit rebase master\n\n执行后\n\n![](https://img-blog.csdnimg.cn/12b959efcc454da5a15b9fdec493d61b.png?)\n\n最后把提取的C和D接到M后面，注意这里的接法，官方没说清楚，实际是会依次拿M和C、D内容分别比较，处理冲突后生成新的C’和D’\n\n无论是个人单机开发，还是公司协作开发，只要没有特殊需求，用merge准没错！！！\n\n不要用rebase。\n\n# Git blame\ngit blame用来追溯一个指定文件的历史修改记录\ngit blame filename\n\n","tags":["Git"]},{"title":"人工智能学习","url":"/blog/2024/03/04/ai/chartGpt/","content":"\n","tags":["ai"]},{"title":"系统架构知识点","url":"/blog/2024/02/22/java/architecture/","content":"\n# 系统架构发展\n\n> 单一应用架构->垂直应用架构（将整个系统按应用模块划分多个系统）->分布式服务架构(集群) ->流动计算架构微服务架构 -> ?\n\n### 分布式\n分布式就是将垂直架构里面共性的业务逻辑抽取出来作为独立的服务。\n    缺点，系统间耦合度变高关系错综复杂难以维护。\n    ![分布式](http://681314.com/zb_users/upload/2023/05/20230505211930_68021jpg)\n\n### SOA架构\n基于分布式架构，增加一个调度中心对集群进行实时管理，资源调度和治理中心，面向服务的架构SOA。\n    ![SOA](http://681314.com/zb_users/upload/2023/05/20230505211930_47905jpg)\n    \n    优点\n    - 使用注册中心解决了服务间调用关系的自动调节\n    缺点\n    - 服务间会有依赖关系一旦某个环节出错会影响较大( 服务雪崩 )。\n    - 服务关心复杂运维、测试部署困难。\n\n\n### 微服务架构\n   SOA的基础上进行彻底拆分服务\n    ![微服务](http://681314.com/zb_users/upload/2023/05/20230505211930_66891jpg)\n    \n    优点\n    - 服务原子化拆分独立打包，部署和升级保证每个微服务清晰的任务划分利于扩展.\n    - 微服务之间采用RESTful等轻量级Http协议相互调用。\n    - 服务各自有自己单独的职责服务之间松耦合避免因一个模块的问题导致服务崩溃\n    缺点\n    - 分布式系统开发的技术成本高容错、分布式事务等。\n    总结\n    - 服务治理和服务监控关键。\n    - 多服务运维难度随着服务的增加运维的压力也在增大\n\n### 服务治理\n- 服务注册\n- 服务发现\n- 服务剔除\n\n\n### 服务调用\n- RESTFul http协议 性能低，灵活度高 微服务架构\n- RPC     tcp 性能高 灵活度低  soa架构\n\nRPCRemote Promote Call一种进程间通信方式\n- 允许像调用本地服务一样调用远程服务。RPC框架的主要目标就是让远程服务调用更简单、透明。RPC框架负责屏蔽底层的传输方式、序列化方式和通信细节。\n- 开发人员在使用的时候只需要了解谁在什么位置提供了什么样的远程服务接口即可并不需要关心底层通信细节和调用过程。》\n\n### 服务网关\n\n为了解决，调用不同的url,跨域问题，身份认证。\nAPI网关，统一接入到API网关层由网关统一接入和输出。\n\n一个网关的基本功能有统一接入、安全防护、协议适配、流量管控、长短链接支持、容错能力\n\n有了网关之后各个API服务提供团队可以专注于自己的的业务逻辑处理而API网关更专注于安全、流量、路由等问题。\n\n![](http://681314.com/zb_users/upload/2023/05/20230505211931_25292jpg)\n\n### 服务容错\n防止雪崩的的三个思想，不被外界影响，不被上游请求压垮，不被下游请求拖垮。\n\n### 链路追踪\n随着微服务架构的流行服务按照不同的维度进行拆分一次请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上这些软件模块有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器横跨多个不同的数据中心。因此就需要对一次请求涉及的多个服务链路进行日志记录性能监控即链路追踪。\n\n# 微服务常见的解决方案\n\n1. ServiceComb 华为云 apache\n2. SpringCloud （spring Cloud并没有重复制造轮子它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。）\n3. Spring Cloud Alibaba\n4. Dubbo+Zookeeper \n   Dubbo是什么\n   Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC一种远程调用 分布式服务框架SOA致力于提供高性能和透明化的RPC远程服务调用方案以及SOA服务治理方案。因为是阿里开源项目国内很多互联网公司都在用已经经过很多线上考验。内部使用了 Netty、Zookeeper保证了高性能高可用性\n\n\n# 分布式注册中心\n注册中心: nacos ,zookeeper ,nacos ,eureka,consul\n\n微服务相关文章\n[《从 0 开始学微服务》阅读笔记](https://blog.stdioa.com/2019/03/geektime-microservice-notes/index.html)\n\n[Zookeeper入门级万字总结](https://zhuanlan.zhihu.com/p/352301245)\n\n[微服务（Microservices）【翻译】](https://cloud.tencent.com/developer/article/1034295)","tags":["Java","Web","架构"]},{"title":"AI相关记录","url":"/blog/2024/02/21/ai/webnote/","content":"\n# AI技术相关知识记录\n## GPT 问答\n    - https://beta.theb.ai/home 付了费的，钱还没用完\n\n## 图像生成，视频生成，\n    - https://gencraft.com/prompt 还是挺厉害的，就是要充值。\n    - https://discord.com/invite/pika  免费的，内容挺多有点意思\n\n## 自动写代码\n","tags":["AI","随笔"]},{"title":"JVM学习1","url":"/blog/2024/02/10/java/jvm/","content":"\n# JVM\n绕不过的话题，肝起来，盘它。\n喜欢问是吧。\n\n根据wiki来学\n## jvm是什么\nJava virtual machine java的虚拟机。\n\n- 一种能够执行Java字节码的虚拟机，以堆栈结构机器来实现。最早由Sun微系统所研发并实现第一个实现版本，是Java平台的一部分，能够执行以Java语言写作的软件程序\n- Java虚拟机有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。通过对中央处理器（CPU）所执行的软件实现，实现能执行编译过的Java程序码（Applet与应用程序）。\n- 作为一种编程语言的虚拟机，实际上不只是专用于Java语言，只要生成的编译文件符合JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。此外，除了甲骨文公司提供的Java虚拟机，也有其他开源或闭源的实现。\n\nwiki的知识点也只是简单说下。\n有个文章讲的比较细[聊到JVM](https://zhuanlan.zhihu.com/p/214027455)\n\n### Java虚拟机主要分为五大模块\n1. 类装载器子系统\n2. 运行时数据区\n3. 执行引擎\n4. 本地方法接口\n5. 垃圾收集模块","tags":["Java","Jvm"]},{"title":"随手记","url":"/blog/2024/02/10/cmd/mix/","content":"总算找到个能放一堆杂七杂八知识的地方了\n\n# tabs outliner 删掉所有的Crash\n```\nlet i = 0; let t = setInterval(() => { let n = treeView.treeModel.currentSession_rootNode.subnodes[i]; if (n.getNodeText().includes(\" (crashed \")) { console.log(`Removing node ${n.getNodeText()}`, n); n.removeOwnTreeFromParent(); } else { i++; } if (i == treeView.treeModel.currentSession_rootNode.subnodes.length) { clearInterval(t); } }, 100);\n\n```\n[git如何避免”warning: LF will be replaced by CRLF“提示？](https://www.zhihu.com/question/50862500)\n最简单办法 git config --global core.autocrlf false\n\n\n[Jenkins+gitlab自动化部署java应用（适合初学者）](https://blog.csdn.net/qq_42933340/article/details/131059727)\n\n私服能做的事情 [某乎](https://www.zhihu.com/question/40854395)\n- 博客\n- 私服\n- ss\n- Nextcloud 私人云盘 部署方式 https://zhuanlan.zhihu.com/p/62987726 https://zhuanlan.zhihu.com/p/31035773\n- frp，树莓派，物联网\n- Emby?看电影\n- uptimeRobot 服务监控\n- netData监控\n\n\n# 一些杂七杂八的玩意\n奥卡姆剃刀原理\n“如无必要，勿增实体” （Entities should not be multiplied unnecessarily）\nNumquam ponenda est pluralitas sine necessitate.（避重趋轻）\nPluralitas non est ponenda sine necessitate.（避繁逐简）\nFrustra fit per plura quod potest fieri per pauciora.（以简御繁）\nEntia non sunt multiplicanda praeter necessitatem.（避虚就实）\n\n# 书籍\n《写给大家看的设计书》：设计相关\n《点石成金》：Web 用户体验相关\n《鸟哥的Linux私房菜》：Linux 系统相关\n大型网站技术架构 https://e.dangdang.com/pc/reader/index.html?id=1900450642\nDevops https://e.dangdang.com/pc/reader/index.html?id=1901321311\n\n单元测试\n\n# 网络安全相关\n\n春秋云镜WP https://github.com/superlink996/chunqiuyunjingbachang?tab=readme-ov-file\n\n各种平台地址 https://www.zhihu.com/question/267204109\n\n靶场攻略 | 网络安全靶场合集 https://blog.csdn.net/Python_0011/article/details/133759740\n","tags":["随笔","cmd"]},{"title":"JAVA基础笔记","url":"/blog/2024/02/10/java/base1/","content":"# 基础知识点上\n\nJDK，8以前，JVM，基础库，javac，javadoc，jdb等等都是混在一起。\nJDK9以后增加了94个模块+jlink生成比较小的jre。\n\n字节码解释过程\n![](https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code-with-jit.png)\nJIT通过 对热点代码HotSpot 惰性评估方式，保存热点代码的方式提高执行效率。\n\n---\n\nJDK9 引入了AOT\n新的编译模式，在程序执行前编译成字节码，静态编译。可以避免jit预热，加快java程序启动速度。\n减少内存和增强java程序的安全性。适合云原生场景。\n更进一步，GraalVM 。\n缺点，不支持反射，动态代理，动态加载，JNI。像Spring，GCLIB都没法用了。\n\n---\n\nOpenJdk,https://github.com/openjdk/jdk\nJDK8u221 之前只要不升级可以无限期免费。OpenJDK 是完全免费的。\n\n---\n\nJava vs C++\njava没指针，java单继承，但是可以多继承接口。\njava有gc，C++需要自己释放。\nC++还能重载操作符\n\n---\n\n《Clean Code》这本书明确指出：\n代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。\n\n标识符，关键字，true，false，null字面值\n自增    ++a先自增再赋值， a++先赋值后自增\n\n位移运算 <<,>>, >>> 快速幂算法就用到，还有快速求奇偶数。HashMap hash方法也用到。\n<< 左移，高位丢弃，低位补零\n>> 右移带符号，高位补符号，低位丢弃，正高位数补0，负高位数补1.\n>>> 无符号又移，忽略符号位，空位都以0补齐。\ndouble，float二进制中表现特殊，不能进行移位操作，只有int，long才能移位\n如果移位超过占位数，会先求余再进行移位操作。\n\n```\n/ ^：按位异或\n// >>>:无符号右移，忽略符号位，空位都以0补齐\nreturn (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n```\n\ncontinue，跳一次循环，break跳出循环体继续执行。return结束方法。\n\njava基本类型，byte short，int，long。 float，double，char，boolean.\n\n包装类型vs基本类型\n- 包装类型可以用泛型，基本类型占用空间小，包装类型不复制是null，基本类型有默认值\n- 基本类型用 ==判断，包装类型用equals()方法。\n- 基本类型如果是局部变量，放到栈中，如果是成员变量存放到堆中。包装类型都存放到堆中。\n\n基本类型的包装类型基本都用到了缓存机制来提升性能。比如默认创建[-128,127]的相应缓存数据\n如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。\n两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。\n\n所有整型包装类对象之间值的比较，全部使用 equals 方法比较。 \n![](https://oss.javaguide.cn/github/javaguide/up-1ae0425ce8646adfb768b5374951eeb820d.png)\n\n自动装箱与拆箱\nInteger i = 10;  //装箱\nint n = i;   //拆箱\n从字节码中，我们发现装箱其实就是调用了 包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法。\nInteger i = 10 等价于 Integer i = Integer.valueOf(10)\nint n = i 等价于 int n = i.intValue();\n注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。\n\n浮点数精度丢失\n这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。\n[计算机系统基础（四）浮点数](http://kaito-kidd.com/2018/08/08/computer-system-float-point/)\nBigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。\n[BigDecimal 详解](https://javaguide.cn/java/basis/bigdecimal.html#bigdecimal-%E7%AD%89%E5%80%BC%E6%AF%94%E8%BE%83%E9%97%AE%E9%A2%98)\n\n超过long可以用，BigInteger。\n\n变量，成员变量，局部变量。语法形式，存储方式，生存时间，默认值。\n\n字符型常量，字符串常量。char，String\n方法返回值。\n\n重载，重写。\n\nJava5支持定义可变长参数，允许在调用方法时传入不定长度的参数\npublic static void method1(String... args) \n可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数\npublic static void method2(String arg1, String... args) {\n\n上END\n\n---\n\n# 基础中\n\n### 面向对象\n### Object\nhashCode,获取哈希码，散列码。\nJava 中的任何类都包含有 hashCode() 函数，Object 的 hashCode() 方法是本地方法，也就是用 C 语言或 C++ 实现的。\n散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）\nJava 启蒙书《Head First Java》:为什么要有 hashCode？\n> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashCode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的 hashCode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashCode 值的对象，这时会调用 equals() 方法来检查 hashCode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。\n\n这是因为两个对象的hashCode 值相等并不代表两个对象就相等。\n\n- 如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。\n- 如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。\n- 如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。\n\n为什么重写 equals() 时必须重写 hashCode() 方法？因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。\n\n\n### String\nString、StringBuffer、StringBuilder 的区别\n- 可变性，String不可变。另外两个继承自 AbstractStringBuilder。提供了append\n- 线程安全\nString 线程安全，可以理解为常量。\nStringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的\nStringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n- 性能\n每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n\n对于三者使用的总结：\n操作少量的数据: 适用 String\n单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder\n多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer\n\nString 真正不可变有下面几点原因：\n1. 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。\n2. String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。\n\nJava 9 之后，String、StringBuilder 与 StringBuffer 的实现改用 byte 数组存储字符串。\n\nJava 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。\n字符串对象通过“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。\n不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象。\n\nStringBuilder 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 StringBuilder 对象。\n如果直接使用 StringBuilder 对象进行字符串拼接的话，就不会存在这个问题了。\n\n使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。\nString 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。 Object 的 equals 方法是比较的对象的内存地址。\n\n字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。\n```\n// 在堆中创建字符串对象”ab“\n// 将字符串对象”ab“的引用保存在字符串常量池中\nString aa = \"ab\";\n// 直接返回字符串常量池中字符串对象”ab“的引用\nString bb = \"ab\";\nSystem.out.println(aa==bb);// true\n```\nString.intern() 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：\n\n在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 常量折叠(Constant Folding) 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到：\n常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。对于 String str3 = \"str\" + \"ing\"; 编译器会给你优化成 String str3 = \"string\"; 。\n我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。\n\n不过，字符串使用 final 关键字声明之后，可以让编译器当做常量来处理。\n\n---\n\n# 基础下\n\n### 异常\n\nException 和Error有共同祖先，但是Error没法catch。\nUnchecked Exception 即 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。\nRuntimeException 及其子类都统称为非受检查异常\n- NullPointerException(空指针错误)\n- IllegalArgumentException(参数错误比如方法入参类型错误)\n- NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）\n...\n\n不要在 finally 语句块中使用 return! 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。\n\nfinally的代码也有可能不执行\nfinally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。\n程序所在的线程死亡。\n关闭 CPU。 \n\n### 泛型\njdk 5引入新特性，\n泛型类、泛型接口、泛型方法。\n```\n//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型\n//在实例化泛型类时，必须指定T的具体类型\npublic class Generic<T>{\n\n    private T key;\n\n    public Generic(T key) {\n        this.key = key;\n    }\n\n    public T getKey(){\n        return key;\n    }\n}\n```\n\n### 反射\n\n\n\n### 注解\n\n### SPI\n\n### 序列化，反序列化\n\n### I/O\n\n### 语法糖\n\n\n\n\n# 集合\n\n![](https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png)\n\nHashMap通过 jdk1.8以前，数组+链表组成。拉链法解决解决哈希冲突。1.8以后在链表长度大于阈值，默认。的时候转化为红黑树。\n\nLinkedHashMap继承自HashMap，增加了一条双向链表。\n\nHash算法\n散列算法，从任意文件中创造小的数字的指纹的方法。\nMD5系列，SHA系列。\nMD5和SHA1已经被破解，推荐用SHA2-256\n（彩虹表）\n哈希碰撞\n\nHash冲突，两个或者更多的输入值被哈希函数映射到同一hash值。\n解决方法，\n1. 链地址法（separate chaining） 常见处理方法，将哈希表每一个位置看做一个桶当新的元素哈希值冲突时，我们可以将它添加到同一哈希值的其他元素的链表中。例如，Java的HashMap就是用链表和红黑树（链表长度大于一定阈值时转为红黑树）解决冲突的\n2. 开放地址法 \n3. 再哈希法 Rehashing \n4. 公共溢出法\n\n\n\n---\n几个目标，\n1. 彻底搞懂反射\n2. 泛型的一些用法","tags":["Java"]},{"title":"hexo常用命令","url":"/blog/2024/02/10/cmd/hexo/","content":"\n- 生成文件 hexo generate\n- 部署 hexo deploy\n- 创建文章写作 `hexo new [layout] <title>  layout有三种 post page draft 参数 path 路径 -r替换`\n- 例子 `hexo new post --path essay/markdown \"MarkDown知识\" `\n\nhexo new post --path java/jvm \"JVM学习1\"\n\nhexo new post --path java/architecture \"系统架构知识点\"\n\nhexo new post --path ai/chartGpt \"人工智能学习\"\n\nhexo new post --path essay/Git \"Git相关知识\"\n\nhexo new post --path essay/web_skill \"web技巧\"\n\nhexo new post --path kotlin/base \"kotlin基本语法\"\n\nhexo new post --path Spring/spring-security \"Spring-Security6.0\"\n\nhexo new post --path web3/base \"web3基础了解\"\n\n","tags":["cmd","hexo"]},{"title":"MarkDown知识","url":"/blog/2024/02/10/essay/markdown/","content":"\n- [官方教程](https://markdown.com.cn/)\n- [官方例子](https://markdown.com.cn/editor/)\n\nMarkdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。\n可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。\n\n千万不要被「标记」、「语言」吓到，Markdown的语法十分简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。\n\n就是这十个不到的标记符号，却能让人优雅地沉浸式记录，专注内容而不是纠结排版，达到「心中无尘，码字入神」的境界。\n\n## Markdown 标题语法\n`#`的数量代表了标题的级别。 用``包住就能写#号`例如，添加三个 # 表示创建一个三级标题 (<h3>) (例如：### My Header)。`\n\n可以和html混合用。\n\n还可以在文本下方添加任意数量的 == 号来标识一级标题，或者 -- 号来标识二级标题。\n\nheader 1\n====\nheader 2\n----\n\n# Markdown 段落\n要创建段落，请使用空白行将一行或多行文本进行分隔。\n不要用空格（spaces）或制表符（ tabs）缩进段落。\n\n# Markdown 换行语法\n在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(<br>)。\n\n# 强调\n# 引用\n要创建块引用，请在段落前添加一个 > 符号。\n> Dorothy followed her through many of the beautiful rooms in her castle.\n\n块引用可以包含多个段落。为段落之间的空白行添加一个 > 符号。\n> Dorothy followed her through many of the beautiful rooms in her castle.\n>\n> The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.\n\n块引用可以嵌套。在要嵌套的段落前添加一个 >> 符号。\n> Dorothy followed her through many of the beautiful rooms in her castle.\n>\n>> The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.\n\n块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。\n\n# Markdown 列表语法\n要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。\n1. First item\n2. Second item\n3. Third item\n4. Fourth item\n\n要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。\n- First item\n- Second item\n- Third item\n- Fourth item\n\n要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符，如下例所示：\n*   This is the first list item.\n*   Here's the second list item.\n\n    I need to add another paragraph below the second list item.\n\n*   And here's the third list item.\n\n引用块 >\n\n代码块\n代码块通常采用四个空格或一个制表符缩进。当它们被放在列表中时，请将它们缩进八个空格或两个制表符。\n1.  Open the file.\n2.  Find the following code block on line 21:\n\n        <html>\n          <head>\n            <title>Test</title>\n          </head>\n\n3.  Update the title to match the name of your website.\n4.  \n图片\n` ![Tux, the Linux mascot](/assets/images/tux.png)`\n\n# Markdown 代码语法\n要将单词或短语表示为代码，请将其包裹在反引号 (`) 中。\n\n如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(``)中。\n\n要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。\n\n# Markdown 分隔线语法\n要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (---) 或下划线 (___) ，并且不能包含其他内容。\n*** \n---\n___\n# Markdown 链接语法\n链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。\n\n超链接Markdown语法代码：`[超链接显示名](超链接地址 \"超链接title\")`\n\n对应的HTML代码：`<a href=\"超链接地址\" title=\"超链接title\">超链接显示名</a>`\n\n链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。\n\n这是一个链接 [Markdown语法](https://markdown.com.cn \"最好的markdown教程\")。\n\n使用尖括号可以很方便地把URL或者email地址变成可点击的链接。\n<https://markdown.com.cn>\n<fake@example.com>\n\n# Markdown 图片语法\n# Markdown 转义字符语法\n要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \\ 。\n\n# Markdown 内嵌 HTML 标签\n\n\n# Markdown 围栏代码块\nMarkdown基本语法允许您通过将行缩进四个空格或一个制表符来创建代码块。如果发现不方便，请尝试使用受保护的代码块。根据Markdown处理器或编辑器的不同，您将在代码块之前和之后的行上使用三个反引号（(```）或三个波浪号（~~~）。\n\n```\n{\n  \"firstName\": \"John\",\n  \"lastName\": \"Smith\",\n  \"age\": 25\n}\n```\n许多Markdown处理器都支持受围栏代码块的语法突出显示。使用此功能，您可以为编写代码的任何语言添加颜色突出显示。要添加语法突出显示，请在受防护的代码块之前的反引号旁边指定一种语言。\n```json\n{\n  \"firstName\": \"John\",\n  \"lastName\": \"Smith\",\n  \"age\": 25\n}\n```","tags":["笔记"]},{"title":"近期学习笔记","url":"/blog/2024/02/08/essay/log2402/","content":"近期学习的记录\n\n## [Java 体系知识](https://pdai.tech/)\n### 高并发架构\n消息队列 0/8\n为什么用消息队列？ 场景是海量并发请求的时候，排队处理。\n优点，缺点。\n高可用，重复消费问题，可靠性传输，顺序性，架构设计一个消息队列\n\n消息队列核心场景，解耦，异步，削峰\n解耦\n\n\n## CA证书\nCA证书是电子商务认证授权机构（CA, Certificate Authority），也称为电子商务认证中心，是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。\nCA证书一般用于HTTPS服务中的SSL或TSL协议中,是一种确保服务器或客户端的合法性的一种证书\n\n签发步骤，1.申请认证 , 2.审核信息, 3.签发证书 4.返回证书 5.验证证书 6.密钥协商 \n","tags":["笔记"]},{"title":"Hello World","url":"/blog/2024/02/07/essay/hw/","content":"新年新气象。\n\n曾经的WordPress博客挂了。 非常可惜，那么，不破不立，重新再来吧。\n\n这次使用github作为博客仓库，整了hexo和aircloud主题。就算哪天服务器down掉了，只要GitHub还活着，文章内容就还一直都在。\n\n不过这个主题的文章貌似没什么层级，不过问题也不大。\n\n---\n\n我发现这种写文章的模式其实也蛮有意思的。比起以前用wordpress，这种方式更符合程序员的思维模式。\n\n本地vscode编辑，甚至还有编辑器插件Typora（其实不是太好用，还是MarkDown更好一些）。然后，hexo g一下，deploy就直接到github上面pull了。然后服务器拉一下就完事。\n\n后面有兴趣的话写个远程调用的小脚本，直接本地调用过去更新远程服务器，就更简单了。\n\n重新开始，希望以后记录笔记还是多记录些有意义，深入点的内容。毕竟已经有CSDN了不是么。\n\n测试一下插入一个本地图片\n\n![1707380007715](/img/post/1707380007715.png)\n","tags":["随笔"]}]